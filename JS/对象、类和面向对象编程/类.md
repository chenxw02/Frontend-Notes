# 类

## 概述

ES6 中的类（面向对象编程）背后使用的仍然是原型和构造函数的概念

## 创建

```js
class Person(arg) {}

// 不需要传参可省略括号
const Animal = class {};

// 重命名
const Cattie = class Cat {};
```

* 必须先声明后使用，且无声明提升
* 类的作用域为块

## 构成

类的构成：

* 构造函数方法
* 实例方法
* `get`
* `set`
* 静态类方法

类的性质：

* 内部代码在严格模式执行
* 首字母大写（非强制要求）

## `constructor`

* 使用 `this` 返回构建好的对象
* 允许返回其它对象
* 如果没有引用接收返回的对象，这个对象会被销毁

* 构造函数不是必须的，不定义构造函数相当于将构造函数设为空函数

### 实例化

使用 `new` 关键字实例化一个对象，实例化的过程和对象实例化过程类似

* `new` 是必须的。普通构造函数不使用 `new`，返回的对象会被添加到 `window` 上；类的构造函数不使用 `new` 则会抛出错误

### 性质

类中定义的 `constructor` 不会被当成构造函数，具体来说：

* 实例化的对象不是 `constructor` 的 `instance`
* 直接使用 `constructor` 而非 `className` 实例化的对象不是 `class` 的 `instance`

```js
class Person {}

let p1 = new Person();

console.log(p1.constructor === Person);         // true
console.log(p1 instanceof Person);              // true
console.log(p1 instanceof Person.constructor);  // false

let p2 = new Person.constructor();

console.log(p2.constructor === Person);         // false
console.log(p2 instanceof Person);              // false
console.log(p2 instanceof Person.constructor);  // true
```

类的行为与其它对象相同，具体来说：

* 可以作为参数传递
* 可以被定义在任何地方

```js
// 类可以像函数一样在任何地方定义，比如在数组中
let classList = [
  class {
    constructor(id) {
      this.id_ = id;
      console.log(`instance ${this.id_}`);
    }
  }
];

function createInstance(classDefinition, id) {
  return new classDefinition(id);
}

let foo = createInstance(classList[0], 3141);  // instance 3141
```

## 成员

成员即属性和方法；通过类的语法可以方便地定义存在于实例上的成员、存在于原型上的成员以及存在于类本身的成员，具体来说：

* 实例成员支持定义属性和方法
* 原型成员和类成员只支持定义方法

### 实例方法和属性

* 在 `constructor` 内部 `this` 定义的属性和方法是实例成员，这些成员存在于实例上，即不会在原型上共享
* 允许在实例化后追加成员

### 原型方法

* 在类内部，`constructor` 外部定义的方法是原型方法，这些方法存在于原型上，被所有实例共享
* 支持定义 `get` 和 `set`
* 原型方法内部的 `this` 指向调用该方法的对象
* 不支持定义属性，具体来说，在此定义的属性无法初始化，且无法通过实例进行修改

```js
class Person {
  name = 'Jake';
}
// Uncaught SyntaxError: Unexpected token

const person1 = Person();
person1,
```

```js
class Person {
  name;
}
// Uncaught SyntaxError: Unexpected token

const person1 = Person();
person1,name = "xiaowei";
console.log(person1.name); // undefined
```

### 静态方法

即静态成员，具体来说：

* 使用 `static` 关键字定义的方法为静态方法
* 静态方法用于执行不特定于实例的操作，不要求存在实例
* 静态方法内部 `this` 指向类本身
* 静态方法适合作为实例工厂

```js
class Person {
  constructor(age) {
    this.age_ = age;
  }

  sayAge() {
    console.log(this.age_);
  }

  static create() {
    // 使用随机年龄创建并返回一个 Person 实例
    return new Person(Math.floor(Math.random() * 100));
  }
}

console.log(Person.create()); // Person { age_: ... }
```

### 外部定义

正如上面所说，类内部不支持显式地定义原型属性和静态属性，但可以在外部手动添加，具体来说：

* 使用 `className.xxx` 添加静态属性
* 使用 `className.prototype.xxx` 添加原型属性

```js
class Person {}

Person.greeting = "hello";

Person.prototype.Name = "xiaowei";
```

## 迭代器和构成器

* 支持在类和原型上定义迭代器和生成器
* 支持添加一个默认迭代器，将实例变成可迭代对象

## 继承

### 单继承

使用 `extends` 关键字进行单继承，可以继承类和普通构造函数

### `super()`



