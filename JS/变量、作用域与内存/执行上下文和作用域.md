# 执行上下文和作用域

## 执行上下文

### 概述

* 执行上下文分为全局上下文、函数上下文和 `eval()` 调用内部的上下文
* 变量和函数的上下文决定了它们可以访问哪些数据
* 每个上下文都有一个关联的**变量对象**，这个上下文中定义的所有变量和函数都存在于这个对象上
* 无法通过代码直接访问变量对象，但后台处理数据会用到它
* 上下文在其所有代码都执行完毕后被销毁，包括定义在它上面的所有变量和函数

### 全局上下文

* 全局上下文是最外层的上下文
* 浏览器中全局上下文是 `window` 对象
* 所有通过 `var` 定义的全局变量和函数都会成为 `window` 的属性和方法
* 使用 `let` 和 `const` 的顶级声明不会定义在全局上下文中，但在作用域解析上效果是一样的

### 函数上下文

* 每个函数调用都有自己的上下文
* 当函数执行流进入函数时，函数的上下文被压入到一个**上下文栈**中，在执行完成后，该上下文被弹出，控制权返回给之前的执行上下文
* ES 程序的执行流通过上下文栈进行控制

### 作用域链

* 上下文中的代码在执行中会创建一个作用域链，这个作用域链由许多个变量对象组成
* 当前执行的函数上下文的变量对象为于作用域链最顶端，此时函数的活动对象作为变量对象（活动对象最初只有一个定义变量 `arguments`，即函数的参数）
* 作用域链中的下一个变量对象是包含这个函数的函数的变量对象，直到全局上下文变量对象
* 作用域链从上往下访问，不能从下往上访问

```js
var color = "blue";

function changeColor() {
  if (color === "blue") {
    color = "red";
  } else {
    color = "blue";
  }
}

changeColor();

/**
changeColor() 执行时的作用域链
- changColor 变量对象
- 全局上下文变量对象
*/
```

### 作用域链增强

使用 `try/catch` 和 `with` 会导致在作用域链的下方临时添加一个上下文：

* `with`：添加指定的对象
* `catch`：创建一个新的变量对象，这个变量对象包含要抛出的错误对象的声明

## 作用域

### `var`

* 添加至最接近的上下文（函数级作用域）
* 声明提升（只提升声明，不会提升赋值行为）

### `let`

* 块级作用域
* 没有声明提升，也就是说：
  * 不能声明前使用
  * 不能重复声明

严格来说，`let` 也是有声明提升的。但 `let` 声明的变量在其声明之前是不可访问的，也就是说：

在` `let 声明提升后，会进入暂时性死区，此时变量无法被访问；只有当真正被声明后，才会从暂时性死区进入作用域，可以被访问和使用

### const

* 行为与 `let` 相似
* 对于对象，有以下特点：
  * 不能再被重新赋值为其它对象
  * 对象的属性可以修改
  * 允许使用 `Object.freeze()` 让整个对象不被修改；修改行为会失效但不会报错
* `const` 在其声明周期中值都不会发生变化，故编译器可以将其替换成实际的值，而不会通过查询表进行变量查找（谷歌 V8 引擎）

## 标识符查找

在使用变量时，必须通过搜索确定这个变量是什么，搜索开始为作用域链前端，一直往下搜索，搜素不到则说明变量未声明。变量搜索规则为：

* 一旦找到变量则停止搜索，也就是说同名的局部变量和全局变量，搜索总是返回局部变量
* 一旦在局部作用域内声明了与全局变量同名的局部变量，该作用域内部的代码都将无法访问该名字的全局变量（除非使用 `window.variable`）
* 访问局部变量比全局变量快，因为不用切换作用域；但 js 引擎在这方面有许多优化，差异正在缩小